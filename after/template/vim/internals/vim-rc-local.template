VimL: "Vim local-vimrc Template File, Luc Hermitte
MuT:  let s:location = fnamemodify(s:path, ':r')
VimL: " Override s:fn computation for local-vimrc case
MuT:  let s:fn = substitute(s:location,'\(\W\|_\)\+', '_', 'g')
MuT:  let s:_prj_kind = s:Param('project_kind', {})
MuT:  let s:_prj_name = s:Param('_prj_name', lh#marker#txt('MyProjectName'))
" ######################################################################
" Always loaded {{{1
" Here goes settings from plugins that are not project aware :(

" 2x:h -> remove file name -> move dir up from .config/
let s:script                = expand("<sfile>:p")
let s:script_dir            = expand('<sfile>:p:h:h')
let s:config_dir            = expand('<sfile>:p:h')
let s:currently_edited_file = expand('%:p')
" let lh#project.auto_detect = 0 " in the case of multi component projects

MuT:  if has_key(s:_prj_kind, 'c') || has_key(s:_prj_kind, 'cpp')
VimL:     call s:Include('vim-rc-global-ccpp', 'vim/internals')
MuT:  endif

" ######################################################################
" Buffer-local Definitions {{{1
" Avoid local reinclusion {{{2
if &cp || (exists("b:loaded_¡s:fn¡")
      \ && (b:loaded_¡s:fn¡ >= s:k_version)
      \ && !exists('g:force_reload_¡s:fn¡'))
  finish
endif
let b:loaded_¡s:fn¡ = s:k_version
let s:cpo_save=&cpo
set cpo&vim
" Avoid local reinclusion }}}2

" ======================[ Check for excluded files => abort {{{2
if empty(s:currently_edited_file)
  call assert_false('Invalid path!')
  let s:currently_edited_file = getcwd()
endif
" If this is a buffer generated by a plugin or a remote file, abort!
if s:currently_edited_file =~ '^{.*}://'
  call lh#log#this('Not a real source file, aborting')
  finish
endif

" If the project has component/modules, detect and set b:component_name here
VimL: " TODO: ask whether component/modules are used
VimL: " For instance:
VimL: "   let s:rel_path_to_current = lh#path#strip_start(s:currently_edited_file, [s:script_dir])
VimL: "   if s:rel_path_to_current !~ 'ITK\|OTB'
VimL: "       " Not ITK/OTB, aborting
VimL: "       call lh#log#this('Not ITK/OTB, aborting')
VimL: "       finish
VimL: "   endif
VimL: "   let b:component_name = matchstr(s:rel_path_to_current, '[^/\\]*')
VimL: "   let b:component_varname = substitute(b:component_name, '[^a-zA-Z0-9_]', '_', 'g')
VimL: "   let s:sources_dir = s:script_dir.'/'.b:component_name

" ======================[ Define the project {{{2
if get(g:, 'g:force_reload_¡s:fn¡', 0)
  " Permit to set new project options if reloading is required
  call lh#let#unlet('b:'.lh#project#_get_varname())
elseif lh#project#is_in_a_project()
  " Abort if a project is already defined
  finish
endif
call lh#project#define(s:, {'name': '<+s:_prj_name+>'})

MuT:  if has_key(s:_prj_kind, 'c') || has_key(s:_prj_kind, 'cpp')
VimL:     call s:Include('vim-rc-local-ccpp', 'vim/internals')
MuT:  endif
MuT:  if has_key(s:_prj_kind, 'cmake')
VimL:     call s:Include('vim-rc-local-cmake', 'vim/internals')
MuT:  endif
VimL: " Bug tracker
VimL: let s:bug_tracker = lh#ui#which('lh#ui#confirm',"Which bug tracker will you use ?", ['None/Another', '&Jira'])
MuT:  if s:bug_tracker == 'Jira'
VimL:     call s:Include('vim-rc-local-jira', 'vim/internals')
MuT:  endif
MuT:  if empty(s:_prj_kind)
VimL:     call s:Include('vim-rc-local-default', 'vim/internals')
MuT:  endif

" ======================[ Other commands {{{2
command! -b -nargs=* LVEcho echo <sid>Echo(<args>)

" ######################################################################
" Global Definitions {{{1
" Avoid global reinclusion {{{2
if &cp || (exists("g:loaded_¡s:fn¡")
      \ && (g:loaded_¡s:fn¡ >= s:k_version)
      \ && !exists('g:force_reload_¡s:fn¡'))
  let &cpo=s:cpo_save
  finish
endif
let g:loaded_¡s:fn¡ = s:k_version
" Avoid global reinclusion }}}2
"------------------------------------------------------------------------
MuT:  if has_key(s:_prj_kind, 'c') || has_key(s:_prj_kind, 'cpp')
VimL:     call s:Include('vim-rc-local-global-ccpp', 'vim/internals')
MuT:  endif

" ======================[ Misc function {{{2
" Function: s:Echo(expr) {{{3
function! s:Echo(expr)
  return a:expr
  " return eval(a:expr)
endfunction
"------------------------------------------------------------------------
" }}}1
